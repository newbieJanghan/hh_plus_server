# 쿼리 최적화

## 상품 목록 조회

**[ 정렬을 위한 단일 컬럼 인덱싱 ]**

- 판매량
- 리뷰수
- 등록 일시
- 카디널리티 순서를 인덱스 생성 시 반영한다. (등록 일시 > 리뷰 수 > 판매량)

**[ 낮은 latency 를 위한 목록 캐싱 ]**

- 추후 수평적 확장을 고려하여 별도의 Redis 서버를 운용한다.
- 정렬, 페이지 정보 등 쿼리 파라미터를 키로 사용, 최대 3페이지까지 캐싱.
- `Read Through`
    - 상품 목록 데이터를 서버가 별도로 가공할 필요가 없다.
    - 첫 조회 시 DB 조회 후 캐시에 저장하는 과정의 부하가 있으므로, 미리 캐시에 저장하는 프로세스를 준비한다.

## 상품 상세 조회

**[ 상품 정보 캐싱 ]**

- 상품 정보와 상품의 리뷰 목록 데이터를 별도로 캐싱한다.
- 리뷰 목록은 실시간으로 갱신해줄 필요는 없지만, 상품 정보에 비해 변경이 잦으므로 ttl 을 짧게 설정한다.
- 똑같은 이유로 `Read Through` 전략을 사용한다.

## 인기 상품 랭킹 조회

> 기존 API 는 요청 즉시 당일 판매량을 계산하고 있다. 응답 시간이 늦어지는 문제는 캐싱으로 해결할 수 있다.  
> 다만 캐시가 준비되어 있지 않은 경우의 DB로 직접 조회하는 경우가 발생할 수 있다.
> 해당 API 의 성능을 확인하고, 통계 테이블과 batch process 를 통해 성능을 개선할 수 있는지 확인한다.

**[ 통계 테이블 ]**

- 현재 인기 상품 조회 API 는 직접 Join 하여 판매량을 계산하고 있으므로, 성능이 느리다.
- 상품 수량이 늘어날 수록 쿼리 속도가 늘어나기 때문에, 통계용 테이블을 별도로 생성하여 판매량을 집계한다.
- 랭킹 갱신 주기에 따라 Batch Process 를 적용한다.

**[ 통계 데이터 Caching ]**

- 랭킹 쿼리(집계 주기, 페이지 등)를 키로 사용, 최대 3페이지까지 캐싱한다.
- `Cache Aside`: 랭킹 테이블의 데이터를 그대로 저장하기보단 상품 목록 데이터로 가공해야 하기 때문.
- 통계 테이블 갱신하는 Batch Process 가 끝나면 캐시를 업데이트한다.